# -*- coding: utf-8 -*-
"""Proyek ML Expert_Ridwan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sp2tkhUxWZO80hc6dAJvfn2SNs0CLmkh

**Nama  : Ridwan Akmal <br>
Universitas : Universitas Negeri Yogyakarta** <br>
          *MSIB 3 DICODING SUBMISSION MACHINE LEARNING TERAPAN(Predictive Analysis)*

# **IMPORT PACKAGE**
"""

import pandas as pd
import io
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import AdaBoostRegressor, RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import mean_squared_error
from sklearn.svm import SVC
from sklearn import metrics
import warnings
warnings.filterwarnings('ignore')

"""# **DATA LOADING**"""

from google.colab import files
up = files.upload()

# Load Tweet dataset
df = pd.read_csv(io.BytesIO(up['Telco-Customer-Churn.csv']))
# Output first five rows
df.head()

df.columns.values

"""# **DATA UNDERSTANDING & EDA**

Mengecek informasi pada data
"""

df.shape

df.info()

"""Informasi Statistik dari data"""

df.describe()

"""Didalam dataset terdapat 20 Kolom 
Kumpulan data mencakup informasi tentang:

- Pelanggan yang pergi dalam sebulan terakhir – kolomnya disebut `Churn`

- Layanan yang telah didaftarkan oleh setiap pelanggan –  phone service, multiple lines, internet services, online security, online backup, device protection, tech support, and streaming TV dan streaming movies

- Informasi akun pelanggan - seperti contract, payment method, paperless billing, monthly charges, and total charges

- Info demografis tentang pelanggan – gender, tenure, lalu Partner, Dependents
"""

# mulai melakukan proses manipulasi data
df = df.drop(['customerID'], axis = 1)
df.head()

df['TotalCharges'] = pd.to_numeric(df.TotalCharges, errors='coerce')
df.isnull().sum()

df[np.isnan(df['TotalCharges'])]

# melihat persebaran data di totalcharges
sns.histplot(data=df, x='TotalCharges')

"""Nah karena distribusinya itu di skewed kita akan lakukan impoutation dg menggunakan median"""

df = df.fillna(df["TotalCharges"].median())

# melihat outliers di beberapa data numeriknya
sns.boxplot(x=df.tenure)

sns.boxplot(x=df.MonthlyCharges)

"""Oke aman semuanya lanjut lagi ke proses berikutnya

# **ANALISIS UNIVARIAT&MULTIVARIAT**
"""

df.columns.values

cat_col = ['gender', 'SeniorCitizen', 'Partner', 'Dependents',
          'PhoneService', 'MultipleLines', 'InternetService',
          'OnlineSecurity', 'OnlineBackup', 'DeviceProtection',
          'TechSupport', 'StreamingTV', 'StreamingMovies', 'Contract',
          'PaperlessBilling', 'PaymentMethod']
num_col = ['Tenure', 'MonthlyCharges', 'TotalCharges']

fig, axes = plt.subplots(4,5,figsize=(25,10))

# biar bisa looping kita akan lakukan flatten

for cat, ax in zip(cat_col, axes.flatten()):
    sns.countplot(cat, data=df,ax=ax)
    ax.grid(color='#FFFFFF', linestyle=':', axis='y', zorder=0,  dashes=(1,5))

plt.figure(figsize=(10, 8))
correlation_matrix = df.corr().round(2)
 
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

import plotly.express as px
import plotly.graph_objects as go

fig = px.histogram(df, x="Churn", color="PaymentMethod", title="<b>Distribusi Payment Method dengan Churn</b>")
fig.update_layout(width=700, height=500, bargap=0.1)
fig.show()

"""- Dapat dilihat dari grafik customer yang churn(pindah) dengan tingkat presentase terttnggi adalah yang menggunakan Elektronik check sebagai Metode Pembayaran.
- Pelanggan yang memilih mailed check,bank transfer, credit card(automatic) sebagai Metode Pembayaran cenderung tidak pindah.
"""

fig = px.histogram(df, x="Churn", color="Contract", barmode="group", title="<b>Distribusi Customer contract terhadap Churn <b>")
fig.update_layout(width=700, height=500, bargap=0.1)
fig.show()

"""- Sekitar 75% pelanggan dengan Kontrak Bulan-ke-Bulan memilih untuk pindah dibandingkan dengan 13% pelanggan dengan Kontrak Satu Tahun dan 3% dengan Kontrak Dua Tahun"""

color_map = {"Yes": "#EB1D36", "No": "#42855B"}
fig = px.histogram(df, x="Churn", color="Dependents", barmode="group", title="<b>Distribusi Dependents terhadap Churn </b>", color_discrete_map=color_map)
fig.update_layout(width=700, height=500, bargap=0.1)
fig.show()

"""- Pelanggan yang tidak memiliki dependents(tanggungan) cenderungnya akan churn"""

color_map = {"Yes": '#F0E161', "No": '#A7D2CB'}
fig = px.histogram(df, x="Churn", color="Partner", barmode="group", title="<b>Distribusi Partners terhadap Churn</b>", color_discrete_map=color_map)
fig.update_layout(width=700, height=500, bargap=0.1)
fig.show()

"""- sama seperti sebelumnya pelanggan yang tidak memiliki partners akan  cenderung churn"""

fig = px.histogram(df, x="Churn", color="TechSupport",barmode="group",  title="<b>Distribusi TechSupport terhadap Churn</b>")
fig.update_layout(width=700, height=500, bargap=0.1)
fig.show()

"""- pelanggan tanpa TechSupport kemungkinan besar akan bermigrasi ke penyedia layanan lain. Terlihat di grafik perbedaanya cukup signifikan antara yang menggunakan TechSupport dan tidak."""

sns.set_context("paper",font_scale=1.1)
ax = sns.kdeplot(df.MonthlyCharges[(df["Churn"] == 'No') ],
                color="#FBDF07", shade = True);
ax = sns.kdeplot(df.MonthlyCharges[(df["Churn"] == 'Yes') ],
                ax =ax, color="#850E35", shade= True);
ax.legend(["Not Churn","Churn"],loc='upper right');
ax.set_ylabel('Density');
ax.set_xlabel('Monthly Charges');
ax.set_title('Distribusi monthly charges terhadap churn');

"""- Pelanggan dengan Biaya Bulanan yang lebih tinggi juga lebih cenderung melakukan churn"""

sns.set_context("paper",font_scale=1.1)
ax = sns.kdeplot(df.tenure[(df["Churn"] == 'No') ],
                color="#0F3460", shade = True);
ax = sns.kdeplot(df.tenure[(df["Churn"] == 'Yes') ],
                ax =ax, color="#F65A83", shade= True); 
ax.legend(["Not Churn","Churn"],loc='upper right');
ax.set_ylabel('Density');
ax.set_xlabel('Tenure');
ax.set_title('Distribusi Tenure terhadap churn');

"""- Customer baru sebagian besar melakukan churn

# **DATA PREPROCESSING**
"""

from sklearn.preprocessing import LabelEncoder

def object_to_int(dataframe_series):
    if dataframe_series.dtype=='object':
        dataframe_series = LabelEncoder().fit_transform(dataframe_series)
    return dataframe_series

df = df.apply(lambda x: object_to_int(x))
df.head()

X = df.drop(columns = ['Churn'])
y = df['Churn'].values

def distplot(feature, frame, color='r'):
    plt.figure(figsize=(8,3))
    plt.title(f"Distribution for {feature}")
    ax = sns.distplot(frame[feature], color= color)

num_cols = ["tenure", 'MonthlyCharges', 'TotalCharges']
for feat in num_cols: distplot(feat, df)

X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, stratify=y, random_state=42)

X_train.shape,y_train.shape ,y_test.shape, X_test.shape

scaler= StandardScaler()

X_train[num_cols] = scaler.fit_transform(X_train[num_cols])
X_test[num_cols] = scaler.transform(X_test[num_cols])

numerical_features = ['tenure', 'MonthlyCharges', 'TotalCharges']
scaler = StandardScaler()
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])
X_train[numerical_features].head()

"""# **MODEL DEVELOPMENT AND EVALUATION**"""

knn_model = KNeighborsClassifier(n_neighbors = 11) 
knn_model.fit(X_train,y_train)
predicted_y = knn_model.predict(X_test)
accuracy_knn = knn_model.score(X_test,y_test)
print("KNN accuracy:",accuracy_knn)

svc_model = SVC(random_state = 1)
svc_model.fit(X_train,y_train)
predict_y = svc_model.predict(X_test)
accuracy_svc = svc_model.score(X_test,y_test)
print("SVM accuracy is :",accuracy_svc)

model_rf = RandomForestClassifier(n_estimators=500 , oob_score = True, n_jobs = -1,
                                  random_state =50, max_features = 0.3, max_depth = 50,
                                  min_samples_leaf = 25)
model_rf.fit(X_train, y_train)
prediction_test = model_rf.predict(X_test)
print ("Random Forest Classifier accuracy is :",metrics.accuracy_score(y_test, prediction_test))

"""Dari hasil akurasi tersebut dapat saya simpulkan model terbaik untuk dataset kali ini adalah algoritma Random Forest dengan hasil 80%. """

from sklearn.metrics import confusion_matrix

model_rf = RandomForestClassifier(n_estimators=500 , oob_score = True, n_jobs = -1,
                                  random_state =50, max_features = 0.3, max_depth = 50,
                                  min_samples_leaf = 25)
model_rf.fit(X_train, y_train)
y_test_pred = model_rf.predict(X_test)

# Form confusion matrix as a DataFrame
confusion_matrix_df = pd.DataFrame((confusion_matrix(y_test, y_test_pred)), ('No churn', 'Churn'), ('No churn', 'Churn'))

# Plot confusion matrix
plt.figure()
heatmap = sns.heatmap(confusion_matrix_df, annot=True, annot_kws={'size': 14}, fmt='d', cmap='YlGnBu')
heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=14)
heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=0, ha='right', fontsize=14)

plt.title('Confusion Matrix for Testing Model\n(Random Forest Classifier)', fontsize=18, color='darkblue')
plt.ylabel('True label', fontsize=14)
plt.xlabel('Predicted label', fontsize=14)
plt.tight_layout()
plt.show()

svc_model = SVC(random_state = 1)
svc_model.fit(X_train, y_train)
y_test_pred = svc_model.predict(X_test)

# Form confusion matrix as a DataFrame
confusion_matrix_df = pd.DataFrame((confusion_matrix(y_test, y_test_pred)), ('No churn', 'Churn'), ('No churn', 'Churn'))

# Plot confusion matrix
plt.figure()
heatmap = sns.heatmap(confusion_matrix_df, annot=True, annot_kws={'size': 14}, fmt='d', cmap='YlGnBu')
heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=14)
heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=0, ha='right', fontsize=14)

plt.title('Confusion Matrix for Testing Model\n(Support Vector Classifier)', fontsize=18, color='darkblue')
plt.ylabel('True label', fontsize=14)
plt.xlabel('Predicted label', fontsize=14)
plt.tight_layout()
plt.show()

knn_model = KNeighborsClassifier(n_neighbors = 11) 
knn_model.fit(X_train,y_train)
y_test_pred = knn_model.predict(X_test)

# Form confusion matrix as a DataFrame
confusion_matrix_df = pd.DataFrame((confusion_matrix(y_test, y_test_pred)), ('No churn', 'Churn'), ('No churn', 'Churn'))

# Plot confusion matrix
plt.figure()
heatmap = sns.heatmap(confusion_matrix_df, annot=True, annot_kws={'size': 14}, fmt='d', cmap='YlGnBu')
heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=14)
heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=0, ha='right', fontsize=14)

plt.title('Confusion Matrix for Testing Model\n(KNN)', fontsize=18, color='darkblue')
plt.ylabel('True label', fontsize=14)
plt.xlabel('Predicted label', fontsize=14)
plt.tight_layout()
plt.show()